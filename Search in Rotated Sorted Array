C:
int search(int* nums, int numsSize, int target){
    if(numsSize==0)     return -1;
    int lo = 0, hi = numsSize-1, mid;
    while(hi-1>lo){                 //如果循环条件就设置hi>lo的话，编译就会越界。
                                      主要是是当lo+1=hi时，mid = lo，这时没有找到target的话，lo=mid-1就越界
                                      c语言还是多考虑指针越界的问题
        mid = lo+(hi-lo)/2;
        if(nums[mid]==target){
            return mid;
        }
        if(nums[mid]>nums[hi]){
            if(target>=nums[lo] && target<nums[mid]){
                hi = mid-1;
            }else{
                lo = mid+1;
            }
        }else{
            if(target>nums[mid] && target<=nums[hi]){
                lo = mid+1;
            }else{
                hi = mid-1;
            }
        }
    }
    if(target==nums[lo])    return lo;
    if(target==nums[hi])    return hi;
    return -1;
}

java：
//java就没有这种问题
class Solution {
    public int search(int[] nums, int target) {
        return binarySe(nums,0,nums.length-1,target);
    }

    private int binarySe(int[] nums, int lo, int hi, int target) {
        if(lo>hi) return -1;
        int mid = lo+(hi-lo)/2;
        if(nums[mid]==target) return mid;
        if (nums[mid] < nums[hi]) {
            if (nums[mid] < target && target <= nums[hi])
                return binarySe(nums, mid + 1, hi, target);
            else
                return binarySe(nums, lo, mid - 1, target);
        } else {
            if (nums[lo] <= target && target < nums[mid])
                return binarySe(nums, lo, mid - 1, target);
            else
                return binarySe(nums, mid + 1, hi, target);
        }


    }
}
